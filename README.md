<!-- Auto generated by build.rs + README_TEMPLATE.md -->
# Nuts

Nuts is a library that offers a simple publish-subscribe API.

## Quick first example
```rust
struct Activity;
let activity = nuts::new_activity(Activity);
activity.subscribe(|_activity, n: &usize| println!("Subscriber received {}", n) );
nuts::publish(17usize);
// "Subscriber received 17" is printed
```

As you can see in the example above, no explicit channel between publisher and subscriber is necessary.
They are only connected because both of them used `usize` as message type.

Nuts enables this simple API by managing all necessary state in thread-local storage.
This is particularly useful when targeting the web.
However, Nuts has no dependencies (aside from std) and therefore can be used on other platforms, too.

## Activities

Activities are at the core of Nuts.
From the globally managed data, they represent the active part, i.e. they can have event listeners.
The passive counter-part is defined by `DomainState`.

Every struct that has a type with static lifetime (anything that has no lifetime parameter that is determined only at runtime) can be used as an Activity.
You don't have to implement the `Activity` trait yourself, it will always be automatically derived if possible.
You only have to register the activity, using `nuts::new_activity` or one of its variants.


### Creating a New Activity

`nuts::new_activity(...)` is the simplest method to create a new activity.
It takes only a single argument, which can be any struct instance or primitive.
This object will be the private data for the activity.

An `ActivityId` is returned, which is a handle to the newly registered activity.
Use it to register callbacks on the activity.

# Example:
```rust
#[derive(Default)]
struct MyActivity {
    round: usize
}
struct MyMessage {
    no: usize
}

// Create activity
let activity = MyActivity::default();
// Activity moves into globally managed stated, ID to handle it is returned
let activity_id = nuts::new_activity(activity);

// Add event listener that listens to published `MyMessage` types
activity_id.subscribe(
    |my_activity, msg: &MyMessage| {
        println!("Round: {}, Message No: {}", my_activity.round, msg.no);
        my_activity.round += 1;
    }
);

// prints "Round: 0, Message No: 1"
nuts::publish( MyMessage { no: 1 } );
// prints "Round: 1, Message No: 2"
nuts::publish( MyMessage { no: 2 } );
```

### Activity Lifecycle

An activity starts in an active lifecycle status.
The only other status is inactive in the current version of Nuts.

The inactive status can be used to put activities to sleep temporarily.
While inactive, the activity will not be notified of events it has subscribed to.
A subscription filter can been used to change this behavior.
(See [`subscribe_masked`](struct.ActivityId.html#method.subscribe_masked))

If the status of a changes from active to inactive, the corresponding [`on_leave`](struct.ActivityId.html#method.on_leave) and [`on_leave_domained`](struct.ActivityId.html#method.on_leave_domained) subscriptions will be called.

If the status of a changes from inactive to active, the corresponding [`on_enter`](struct.ActivityId.html#method.on_enter) and [`on_enter_domained`](struct.ActivityId.html#method.on_enter_domained) subscriptions will be called.0


### Understanding the Execution Order
TODO

## Domains

Domains span multiple [Activities](trait.Activity.html) and allows them to share state.
Library users can define the domains using [`domain_enum!`](macro.domain_enum.html) but each activity can only join one domain.

If data is only used by a single activity, it is usually better to store it in the activity struct itself.
Domains should only be used when data needs to be shared between multiple activities of the same or different types.

For now, there is no real benefit from using multiple Domains, other than data isolation.
But there are plans for the future that will schedule Activities in different threads, based on their domain.

### Creating Domains
TODO
### Using Domains
TODO

## Complete Example
TODO (Share with library level docs)


TODO: Fix README links

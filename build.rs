use std::collections::HashMap;
use std::fs;
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::path::Path;

const HEADER: &'static str = "<!-- Auto generated by build.rs + README_TEMPLATE.md -->";

fn main() -> std::io::Result<()> {
    let out = fs::File::create("README.md")?;
    let mut out = BufWriter::new(out);

    writeln!(out, "{}", HEADER)?;

    let template = fs::File::open("README_TEMPLATE.md")?;
    let template = BufReader::new(template);

    let mut dict = HashMap::new();
    find_snippets_in_directory("src", &mut dict)?;
    for line in template.lines() {
        let line = line?;
        if line.starts_with("@DOC ") {
            let (_, key) = line.split_at(5);
            if let Some(doc) = dict.get(key) {
                writeln!(out, "{}", doc)?;
            } else {
                writeln!(out, "MISSING DOCS: {} not found", key)?;
            }
        } else {
            writeln!(out, "{}", line)?;
        }
    }
    println!("dictioniary: {:?}", dict);

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=README_TEMPLATE.md");
    Ok(())
}

fn find_snippets_in_directory(
    dir: impl AsRef<Path>,
    dict: &mut HashMap<String, String>,
) -> std::io::Result<()> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        let metadata = fs::metadata(&path)?;
        if metadata.is_file() && path.extension().map(|ext| ext == "rs").unwrap_or(false) {
            find_snippets_in_file(path, dict)?;
        } else if metadata.is_dir() {
            find_snippets_in_directory(path, dict)?;
        }
    }
    Ok(())
}

#[derive(PartialEq, Debug)]
enum SearchState {
    OutsideSnippet,
    InsideSnippet,
}
fn find_snippets_in_file(
    path: impl AsRef<Path>,
    dict: &mut HashMap<String, String>,
) -> std::io::Result<()> {
    let file = fs::File::open(&path)?;
    let mut state = SearchState::OutsideSnippet;
    let mut key = None;
    let mut snippet = String::new();
    const START_MARKER: &'static str = "// @ START-DOC ";
    const END_MARKER: &'static str = "// @ END-DOC";
    for (line_number, line) in BufReader::new(file).lines().enumerate() {
        let line = line?;
        let line = line.trim();
        match state {
            SearchState::OutsideSnippet => {
                if line.starts_with(START_MARKER) {
                    state = SearchState::InsideSnippet;
                    let (_start, end) = line.split_at(START_MARKER.len());
                    key = Some(end.to_owned());
                }
            }
            SearchState::InsideSnippet => {
                if line.starts_with(END_MARKER) {
                    state = SearchState::OutsideSnippet;
                    dict.insert(key.take().expect("No key?"), std::mem::take(&mut snippet));
                    println!("cargo:rerun-if-changed={}", path.as_ref().to_str().unwrap());
                } else {
                    snippet += "\n";
                    let uncommented = if let Some(i) = line.find("/// ") {
                        line.split_at(i + 4).1
                    } else if let Some(i) = line.find("///") {
                        line.split_at(i + 3).1
                    } else if let Some(i) = line.find("//! ") {
                        line.split_at(i + 4).1
                    } else if let Some(i) = line.find("//!") {
                        line.split_at(i + 3).1
                    } else {
                        panic!(
                            "Doc comment for README cannot be parsed: file: {}:{}, doc comment: {:?}",
                            path.as_ref().to_str().unwrap(),
                            line_number+1,
                            line
                        )
                    };
                    snippet += uncommented;
                }
            }
        }
    }
    assert_eq!(state, SearchState::OutsideSnippet);
    Ok(())
}
